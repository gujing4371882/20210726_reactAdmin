<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>函数的防抖和节流</title>
</head>
<body>

  <button id="throttle">测试函数节流</button>
  <button id="debounce">测试函数防抖</button>

  <script>

    /** 
     * 点击事件 
    */
    function handleClick () {
      console.log('处理点击事件。。。')
    }

    /**  
     * 节流处理 
     */
    function throttle (callback, delay) {  
      let start = 0 // 保证第一次调用必须调用
      return function () {
        let current = Date.now()
        if(current - start > delay) { // 第二次开始，时间差有没有超过延时时间，超过立马执行    
          callback.apply(this, arguments) 
          start = current
        }
      }
    } 

    /** 
     * 
     * 1> handleClick () 和 2> handleClick 的区别 
     * 1> 函数的调用并执行。结果：处理点击事件。。。
     * 2> 只是调用函数体，将指针指向这个函数体，需要时，再调用。
     * 结果：
     * function handleClick () {
     *   console.log('处理点击事件。。。')
     * } 
     * 
    */
    document.getElementById('throttle').onclick = throttle(handleClick, 1000)
 

    /** 
     * 
     * 防抖
     * 
     */
    function debounce (callback, delay) {
      return function () {
        // 保存this 和 argument 
        const that = this 
        const args = arguments
        // 清理定时器
        if(callback.timeoutId) { 
          clearTimeout(callback.timeoutId)
        }
        // 定时器执行
        callback.timeoutId =  setTimeout( () => {
          callback.apply(that, args)
          // 删除标记
          delete callback.timeoutId
        }, delay)
      }
    }
    /** 防抖 */
    document.getElementById('debounce').onclick = debounce(handleClick, 1000)


  </script>

  
</body>
</html>